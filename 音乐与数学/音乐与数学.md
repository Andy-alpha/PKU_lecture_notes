| dataset               | video input length                    | stride           | camera parameters(train)                                     | evaluate                                                     | range                                                        | note                                                         |
| --------------------- | ------------------------------------- | ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| EgoHumans/(Egoformer) | a clip of 30 seconds                  | 20FPS,210 epochs | EgoFormer 的输入是三幅图像（RGB，左灰度、右灰度），输出包括2D检测、二维/三维人体姿势、每个人的人体形状以及 跨时间的身份关联。<br />train细节未公开。 | 这里假设相机3D pose通过VIO估计出来。BEV重建在相机系中，Tracking转到世界系。<br />是基于优化的方法。 | 估计20m×20m×2.5m，**待确认**                                 | 关于数据如何得到：内参已知，用VIO(visual-inertial odometry algorithm)获得任意坐标系中3D 外参，并merge多个这样得到的轨迹和静止辅助相机的信息，得到extrinsic信息。 |
| EgoBody               |                                       | 30               |                                                              | pose等从egocentric view中预测，同时extrinsics用头戴设备Cam v与固定相机Cam 1视角之差（三角法）计算出来intrinsic已知。<br />以上是基于优化的方法. | 见recording系列中key points.npz中keypoints一列，给出了关键点的3D位置表格,egocentric_color.py:150有定义，且论文中也有，3D欧几里得距离小于5m的居大多数，约8m×8m×2.4m |                                                              |
| Humans in 4D          | 48,有8块GPU，所以batch size是8*48=384 | 1                | 假设K（intrinsic）已知，但extrinsic的t不知道，且因SMPL部分中，θ已经包含了(R, t)的R(设为identity)，只训练如何预测t | 知道2D key points, bbox, center,K（intrinsic）已知，但extrinsic要预测（utils.py pred_camera）， | /                                                            | 训练前先使用ProHMR [37] 得到 pseudo-GT的SMPL parameters θ∗ and β∗ with camera π∗<br />基于loss function |
| TRACE                 | 15                                    | 10               | 都已知，具体而言是预定义好一个投影矩阵P<br />基于loss function | 直接输入视频/图片，得到motion，作者说用world map主要目的不是估计相机，而是直接得到人的轨迹，所以相机的外参和motion都是非常不准确的。 | 单位：m<br />大多数在8m×8m×2.4m<br />少数y变化达到2.5m，多数x,z在6m的范围内变化 |                                                              |



## EgoBody Dataset Information

EgoBody dataset contains 125 sequences, 36 subjects and 15 indoor scenes. Please find more detailed statistics in our paper.

| frames            | train  | val   | test  | total  |
| ----------------- | ------ | ----- | ----- | ------ |
| MVSet             | 116630 | 29140 | 73961 | 219731 |
| EgoSet            | 105388 | 25416 | 68307 | 199111 |
| EgoSet_interactee | 90124  | 23332 | 62155 | 175611 |

- `MVSet`: synchronized frames captured from the Azure Kinects, from multiple third-person views
- `EgoSet`: egocentric RGB frames captured from the HoloLens, calibrated and synchronized with the Kinect frames
- `EgoSet_interactee`: frames where the interactee is visible in the egocentric view





- EgoHumans

    - The number of keypoints J is set to 17 [72]. The encoders are initialized with MAE-Base[38] pretrained weights. For the tracking stage, we adopt ByteTrack’s association settings. For the tracking baselines, we use their MOT17 [21] configuration as default. The input resolution is set to 256 × 192. The model is trained for 210 epochs with AdamW [96] with 5e − 4 learning rate, decayed by 10 at the 170th and 200th epoch on 8 A6000 GPUs on a combination of EgoHumans and COCO dataset. Note only feature-extraction and detection stages of EgoFormer have learnable parameters.

    - 在EgoHumans的calib文件夹中(如EgoHumans/data/01_tagging/001_tagging/ego/aria01/calib)，存在编号与图片对应（如001-601）的特性参数。其中intrinsics 用radtan thin prsim（考虑到了*radtan*畸变模型），是3个数，单位是像素pixel，如[611.5629212486644519 714.3813697404469849 708.8771062093104547]。后面是12个数，绝对值在0-1之间，是外参数extrinsic (3x4),[R,t],R(3x3) t(3x1)。其处理见EgoHumans/egohumans/lib/datasets/aria_camera.py:144。这里显然是将fx和fy与三个中的第一个数等同起来了。剩下两个分别是cx和cy。

    - 在colmap中的Camera list则写得很清楚。如

	```
	# Camera list with one line of data per camera:
    # CAMERA_ID, MODEL, WIDTH, HEIGHT, PARAMS[]
    #Number of cameras: 23
    1 OPENCV_FISHEYE 1408 1408 612.27951973486313 611.81471668912013 704 704 0.40072514410362842 -0.57412259065562377 0.80034478057236236 -0.46206893732721876
    ```

    -  每一份capture通常含有2-6个egocentric view和8-15个secondary view。Aria glass 的分辨率为：1408×1408 for RGB，480×640 for greyscale images。Go Pro的分辨率为3840×2160。

- Humans in 4D

    - GENERAL:

          TOTAL_STEPS: 1_000_000
          
          LOG_STEPS: 1000
          
          VAL_STEPS: 1000
          
          CHECKPOINT_STEPS: 10000
          
          CHECKPOINT_SAVE_TOP_K: 1
          
          NUM_WORKERS: 6
          
          PREFETCH_FACTOR: 2

        TRAIN:

          LR: 1e-5
          
          WEIGHT_DECAY: 1e-4
          
          BATCH_SIZE: 48
          
          LOSS_REDUCTION: mean
          
          NUM_TRAIN_SAMPLES: 2
          
          NUM_TEST_SAMPLES: 64
          
          POSE_2D_NOISE_RATIO: 0.01
          
          SMPL_PARAM_NOISE_RATIO: 0.005

- TRACE

    - trace.yml

        - temp_clip_length: 15 #64 #

             temp_clip_sample_internal: 10 # 6

             test_seq_max_batch_size: 128

             temp_clip_length_eval: 8
    	-  master_batch_size: -1
        
              val_batch_size: 1
        
              batch_size: 6 
        
              nw: 4
        
              nw_eval: 1
        
              lr: 0.00003 # 0.0001 for initial temp+single_featurefusion



# in open3D, camera coordinate is defined as x right, y down, z forward(pointing into image plane), left figure below
        # in pyrender, camera coordinate is defined as x right, y up, z backward(pointing from image plane), right figure below
        #     ^                    ^
        #    /                     |
        #   z Open3D               y  Pyrender        camera coordinates
        # /                        |
        # --- x --->                --- x ---> 
        # |                       /  
        # y                      z
        # |                     /
        # v                    v



TODO: 在论文中速度v 是cm/frame为单位的，查一查cm是在哪里出现的。
统计EgoHumans、EgoBody总共有多少帧/张，每个文件夹里有什么、有多少。

` PYTORCH_CUDA_ALLOC_CONF=max_split_size_mb:2048 CUDA_VISIBLE_DEVICES=1,2,3  HYDRA_FULL_ERROR=1 python train.py exp_name=hmr2 data=mix_all experiment=hmr_vit_transformer trainer=gpu launcher=local`

- 另外一部分

`python release_renderer_fpv_gaze.py --release_data_root=PATH/TO/DATASET  --save_root=PATH/TO/SAVE/RESULTS --recording_name RECORDING_NAME --scene_name SCENE_NAME`

`python release_renderer_fpv_gaze.py --release_data_root=/mnt/cvda/cvda-mesh/xujiayi/EgoBody/egocentric_color/recording_20210907_S04_S03_01  --save_root=/mnt/cvda/cvda-mesh/xujiayi/EgoBody/renderings_ego_img --recording_name recording_20210907_S04_S03_01 --scene_name holo_frame --model_folder /DATA/disk1/cvda-mesh/yunpeng/visualization/smpl/models`

`python release_renderer_fpv_gaze.py --release_data_root=/mnt/cvda/cvda-mesh/xujiayi/EgoBody  --save_root=/mnt/cvda/cvda-mesh/xujiayi/EgoBody --recording_name recording_20210918_S05_S06_01 --model_folder /DATA/disk1/datasets/SMPLX/`

CUDA_VISIBLE_DEVICES=7 python demo.py --video examples/IMG_9732.mov --visualize

tar -xzvf 010_tagging.tar.gz --strip-components=8 && tar -xzvf 011_tagging.tar.gz --strip-components=8





一个能编译通过但是时间测试不通过的代码：https://gitlab.eduxiji.net/202310001101650/oskernel2023-mkdir

同样是能编译通过但是时间测试不通过的代码：https://gitlab.eduxiji.net/202310001101706/oskernel2023-eigenos

https://gitlab.eduxiji.net/202310336101112/LostWakeup



能过66个的代码https://gitlab.eduxiji.net/202314430101100/OSKernel2023-550W

经过采用它的final_qemu3分支，过了，https://gitlab.eduxiji.net/202310336101112/LostWakeup

https://www.bilibili.com/

file:///Users/apple/projects/reports/main.pdf

https://sidbanerjee.orie.cornell.edu/docs/ORIE4520/files/HW3_solns.pdf

http://webdelprofesor.ula.ve/economia/drivas/materias/ProcesosEstocasticos/Libros/A%20first%20course%20in%20stochastics%20Processes%20%5BSamuel%20Karlin,%20Howard%20M.Taylor%5D.pdf

https://www.notion.so/Experiment-Notes-4781be83f16e4c8bbf8fd60970f6276b

https://www.notion.so/Meeting230926-0f888e2d2a9e4b29a544a2f7c948bf4e

https://talkai.info/chat/

https://www.seemac.cn/56052.html

https://course.educg.net/main.jsp

https://gitlab.eduxiji.net/compiler_homework0/compiler/

https://zhuanlan.zhihu.com/p/640953686

https://www.cnblogs.com/zhangleo/p/15963442.html

https://github.com/CaptainHarryChen/StupidSysY2RV/tree/main/src/ast

https://pku-minic.github.io/online-doc/#/lv4-const-n-var/var-n-assign

https://pku-minic.github.io/online-doc/#/misc-app-ref/koopa

https://docs.rs/koopa/latest/koopa/ir/entities/enum.ValueKind.html

https://github.com/CaptainHarryChen/StupidSysY2RV/blob/main/src/ast/ast.cpp

https://pku-minic.github.io/online-doc/#/misc-app-ref/sysy-spec

https://gitlab.eduxiji.net/csc1/nscscc/compiler2021/-/blob/master/SysY%E8%AF%AD%E8%A8%80%E5%AE%9A%E4%B9%89.pdf

https://blog.kylelv.com/?p=883

https://github.com/CodeSpacePlus/Blasphemous_Save_Editor

https://gitlab.eduxiji.net/pku1900012413/compiler1/-/blob/main/src/main.cpp



其中对于数组的处理存在不一致的行为。例如以下代码段尝试复用同一段代码时，会在少数数组的测例上存在CLE。~~此处指11_arr_params.koopa和13_。目前还在寻找原因。~~经过排查，原来是sysy.y写得有问题，漏掉了一个分号，导致语法分析时会出错。

```C++
void *koopa_leftvalue() const override {
        if(type == Array)  {
            koopa_raw_value_data *get;
            koopa_raw_value_t src = (koopa_raw_value_t)symbol_list.GetSymbol(name).number;
            if(src->ty->data.pointer.base->tag == KOOPA_RTT_POINTER) { // 如果是指针，包括指向的内容一起迁移
                koopa_raw_value_t src = (koopa_raw_value_t)symbol_list.GetSymbol(name).number;
                // Create KOOPA raw value data, ``payload''.
                koopa_raw_value_data *payload = new koopa_raw_value_data();
                payload->ty = src->ty->data.pointer.base;
                payload->name = nullptr;
                payload->used_by = empty_koopa_raw_slice(KOOPA_RSIK_VALUE);
                payload->kind.tag = KOOPA_RVT_LOAD;
                payload->kind.data.load.src = src;
                block_maintainer.AddInst(payload);

                bool first = true;
                src = payload;
                for(auto &i : idx) {
                    get = new koopa_raw_value_data();
                    koopa_raw_type_kind *ty = new koopa_raw_type_kind();
                    if(first) { // 对第一个单独处理
                        get->ty = src->ty;
                        get->name = nullptr;
                        get->used_by = empty_koopa_raw_slice(KOOPA_RSIK_VALUE);
                        get->kind.tag = KOOPA_RVT_GET_PTR;
                        get->kind.data.get_ptr.src = src;
                        get->kind.data.get_ptr.index = (koopa_raw_value_t)i->build_koopa_values();
                        first = false;
                    }
                    else {
                        // Load the following part. Store pointer and array. 
                        ty->tag = KOOPA_RTT_POINTER;
                        ty->data.pointer.base = src->ty->data.pointer.base->data.array.base;
                        get->ty = ty;
                        get->name = nullptr;
                        get->used_by = empty_koopa_raw_slice(KOOPA_RSIK_VALUE);
                        get->kind.tag = KOOPA_RVT_GET_ELEM_PTR;
                        get->kind.data.get_elem_ptr.src = src;
                        get->kind.data.get_elem_ptr.index = (koopa_raw_value_t)i->build_koopa_values();
                    }
                    block_maintainer.AddInst(get);
                    src = get;
                }
            }
            else { //其余情况，和对非第一个的处理是一样的。
                for(auto &i : idx) {
                    
                    get = new koopa_raw_value_data();
                    koopa_raw_type_kind *ty = new koopa_raw_type_kind();
                    // begin
                    ty->tag = KOOPA_RTT_POINTER;
                    ty->data.pointer.base = src->ty->data.pointer.base->data.array.base;
                    get->ty = ty;
                    get->name = nullptr;
                    get->used_by = empty_koopa_raw_slice(KOOPA_RSIK_VALUE);
                    get->kind.tag = KOOPA_RVT_GET_ELEM_PTR;
                    get->kind.data.get_elem_ptr.src = src;
                    get->kind.data.get_elem_ptr.index = (koopa_raw_value_t)i->build_koopa_values();
                    // end
                    block_maintainer.AddInst(get);
                    src = get;
                }
            }
            return get;
        }
        else if (type == Num) {
            return (void *)symbol_list.GetSymbol(name).number;
        }
        return nullptr;
    }
```

```C++
void *koopa_leftvalue() const override {
        if(type == Array)  {
            koopa_raw_value_data *get;
            koopa_raw_value_t src = (koopa_raw_value_t)symbol_list.GetSymbol(name).number;

            std::vector<std::unique_ptr<BaseAST>>::const_iterator i = idx.begin(); // initialize iterator


            if(src->ty->data.pointer.base->tag == KOOPA_RTT_POINTER) { // 如果是指针，包括指向的内容一起迁移
                koopa_raw_value_t src = (koopa_raw_value_t)symbol_list.GetSymbol(name).number;
                // Create KOOPA raw value data, ``payload''.
                koopa_raw_value_data *payload = new koopa_raw_value_data();
                payload->ty = src->ty->data.pointer.base;
                payload->name = nullptr;
                payload->used_by = empty_koopa_raw_slice(KOOPA_RSIK_VALUE);
                payload->kind.tag = KOOPA_RVT_LOAD;
                payload->kind.data.load.src = src;
                block_maintainer.AddInst(payload);

                src = payload;

                get = new koopa_raw_value_data();
                //koopa_raw_type_kind *ty = new koopa_raw_type_kind();
                // 对第一个单独处理
                get->ty = src->ty;
                get->name = nullptr;
                get->used_by = empty_koopa_raw_slice(KOOPA_RSIK_VALUE);
                get->kind.tag = KOOPA_RVT_GET_PTR;
                get->kind.data.get_ptr.src = src;
                get->kind.data.get_ptr.index = (koopa_raw_value_t)(*i)->build_koopa_values();
                    
                
                block_maintainer.AddInst(get);
                src = get;
                
                ++i;    // add iterator for one;
            }
             //其余情况，和对非第一个的处理是一样的。
            for(; i!=idx.end(); ++i) {
                // Load the following part. Store pointer and array.
                get = new koopa_raw_value_data();
                koopa_raw_type_kind *ty = new koopa_raw_type_kind();
                // begin
                ty->tag = KOOPA_RTT_POINTER;
                ty->data.pointer.base = src->ty->data.pointer.base->data.array.base;
                get->ty = ty;
                get->name = nullptr;
                get->used_by = empty_koopa_raw_slice(KOOPA_RSIK_VALUE);
                get->kind.tag = KOOPA_RVT_GET_ELEM_PTR;
                get->kind.data.get_elem_ptr.src = src;
                get->kind.data.get_elem_ptr.index = (koopa_raw_value_t)(*i)->build_koopa_values();
                // end
                block_maintainer.AddInst(get);
                src = get;
            }
            return get;
        }
        else if (type == Num) {
            return (void *)symbol_list.GetSymbol(name).number;
        }
        return nullptr;
    }
```

```shell
docker run -it --rm -v /home/$USER/code/compiler_test:/root/compiler hln7897/compiler-dev:M1-Silicon \
  autotest -koopa -s lv9 /root/compiler
```

```ebnf
CompUnit      ::= [CompUnit] (Decl | FuncDef);

Decl          ::= ConstDecl | VarDecl;
ConstDecl     ::= "const" BType ConstDef {"," ConstDef} ";";
BType         ::= "int";
ConstDef      ::= IDENT {"[" ConstExp "]"} "=" ConstInitVal;
ConstInitVal  ::= ConstExp | "{" [ConstInitVal {"," ConstInitVal}] "}";
VarDecl       ::= BType VarDef {"," VarDef} ";";
VarDef        ::= IDENT {"[" ConstExp "]"}
                | IDENT {"[" ConstExp "]"} "=" InitVal;
InitVal       ::= Exp | "{" [InitVal {"," InitVal}] "}";

FuncDef       ::= FuncType IDENT "(" [FuncFParams] ")" Block;
FuncType      ::= "void" | "int";
FuncFParams   ::= FuncFParam {"," FuncFParam};
FuncFParam    ::= BType IDENT ["[" "]" {"[" ConstExp "]"}];

Block         ::= "{" {BlockItem} "}";
BlockItem     ::= Decl | Stmt;
Stmt          ::= LVal "=" Exp ";"
                | [Exp] ";"
                | Block
                | "if" "(" Exp ")" Stmt ["else" Stmt]
                | "while" "(" Exp ")" Stmt
                | "break" ";"
                | "continue" ";"
                | "return" [Exp] ";";

Exp           ::= LOrExp;
LVal          ::= IDENT {"[" Exp "]"};
PrimaryExp    ::= "(" Exp ")" | LVal | Number;
Number        ::= INT_CONST;
UnaryExp      ::= PrimaryExp | IDENT "(" [FuncRParams] ")" | UnaryOp UnaryExp;
UnaryOp       ::= "+" | "-" | "!";
FuncRParams   ::= Exp {"," Exp};
MulExp        ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
AddExp        ::= MulExp | AddExp ("+" | "-") MulExp;
RelExp        ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
EqExp         ::= RelExp | EqExp ("==" | "!=") RelExp;
LAndExp       ::= EqExp | LAndExp "&&" EqExp;
LOrExp        ::= LAndExp | LOrExp "||" LAndExp;
ConstExp      ::= Exp;

```

其中

- 符号 `[...]` 表示方括号内包含的项可被重复 0 次或 1 次.
- 符号 `{...}` 表示花括号内包含的项可被重复 0 次或多次.
- 终结符是由双引号括起的串, 或者是 `IDENT`, `INT_CONST` 这样的大写记号. 其余均为非终结符.

然而中括号、大括号不方便在其中需要的部分插入一些自定义处理函数。所以在实际操作中，有一部分像此类的被替换如下：

`S ::= A{A} C`→`S ::= BC, B ::= A | BA`

lv4本地自动测试的代码：

`docker run -it --rm -v /media/psf/Home/Downloads/compiler_test:/root/compiler hln7897/compiler-dev:M1-Silicon \
  autotest -koopa -s lv4 /root/compiler`

动漫共和国账号：febuc@mailto.plus

密码：123456

# 《暗黑》笔记

1890年，时间机器发明。

人物：

```mermaid
graph LR
1(Ulrich+Katharina)-->Magus

```



# 18



# 1921



# 1955



# 1990



## S1E01

2019年6月21日，Michael（是家中父亲）在家中自杀，留下了“11月4日晚10点13分前勿启”的信。

2019年11月4日早晨，少年Jonas 16岁，父亲死后，母亲Hannah与Ulrich你侬我侬。

少年Jonas骑车路上见到失踪寻人启事，写着少年Eric Obendorf于2019年10月22日失踪。

Winden洞穴有巨响。在片中警察局长Charlotte安抚Obendorf父母后，交叉剪辑显示一个神秘陌生人（穿着兜帽）出现。

少年Jonas和心理治疗师Peter谈话，谈及自己常常梦到父亲Michael，恨他没有留下遗书。

奶奶Ines听的广播中昭示着核电站是1953年建的，1960年启用，将于2020年停用。她拿了当晚要开封的信。

而Ulrich家中，Mikkel还是一个小男孩。他还有一个姐姐Martha和哥哥Magnus。Ulrich骗妻子，说早上买面包去了。

学校里，Je的好朋友B首次出场，表现出对他的哥们情谊。Obendorf父母情绪激动地到学校讨说法。

哥哥Magus抽大麻时，被女生Franziska找上（然后自己抽了一口）。这里有个额外信息，说Katharina（Ulrich老婆）是校长。

Jonas对Martha有好感，但是女生在他居家期间已经和Bartosz成一对了。

Regina家的酒店遇到了还款危机。

Jonas和Bartosz开Franziska的黄色玩笑，并约定去洞穴里找Eric遗留下的毒品爽。

Ulrich的妈妈Jana叫他过来，说自己在森林里看到了黑色的身躯，项上有巨大的头。并且找了了Mads（Ulrich失踪的弟弟）以前爱吃的Raider零食包装。所有事情和33年前一样。

 Jonas和Martha先到了夜晚的森林，等Bartosz和Magnus。其间他们探讨了De javu的效应，仿佛很久之前就来过这片森林。

结果，Magus把小弟弟Mikkel带来了。这样五个人去探险。

Charlotte的公公Helge闯进家长会场，宣称“这种事情再度发生”。

晚上10点14分到了。就在Ines看信时，五人到了洞穴并遇见了先到的Franziska。然后洞里传来怪声，手电也不亮了。

Mikkel消失，与此同时，疑似Michael的人回归。

紧接着第二天白天，发现了一具男童尸体。不过，脸无法辨认，且并不是Mikkel。年龄和特征上，和Ulrich（15岁）在1986年失踪的弟弟Mads（12岁）一致。

最终一幕，Eric出现，被绑架在充满线圈的实验椅上，处于某密闭房间中，脖子上挂了一芬尼硬币。该装置好像副作用是灼烧眼睛，并且使人耳朵里的“耳石”（即判断方向的单元）上下错乱。

## S1E02

时间来到2019年11月5日。

警察要搜查核电站。Eric Obendorf的父亲Jügen Obendorf被Aleksander威胁去秘密清除某些痕迹。与此同时，旅馆来了一位客人。他带有一台机器。后来知道是2052年穿越回来的Jonas。

Jonas似乎在阁楼像一个画廊的地方发现了什么。

Aleksander不愿发生搜查。

Urich发现了Jügen Obendorf在核电厂工作，且有一辆厢型货车可以进出。排查Jüge那边的垃圾场后发现了他和Eric共同制的白色毒品，以及一个罐子。

画面一转，Eric眼睛已经被烧，被人在树林里拖行。

晚上，洞内又传出阵阵低吼，镇上电力时断时续，警局门口凭空多了许多坠落的死鸟。神秘人把剪报上的“Wo ist Mikkel?”（Mikkel在哪儿？）改成了“WANN ist Mikkel?”（Mikkel在什么时间点？）。

其实，Mikkel还活着，但是穿越到了33年前的1986年。他去自己熟知的家，却只能见到他年轻的爸爸Ulrich和妈妈Katharina，兜风去也！

## S1E03

1986年11月5日

Mikkel又去了年轻时期的Jana家，一开始被认作失踪的Marz，后来发现误认后Jana更伤心了。

Ines Kannwald年轻时是护士，此时还没有成家。

少女Charlotte骑自行车，路上见死小鸟，心善把它放进包里。之后带进森林里测量和用于写生。

距这个时间点四个星期前， 11岁的小男孩失踪。年迈的警察Egon Tiedemann（Regina的爷爷）接到了一通电话说死了33头羊开始动身。

此时，Regina的妈妈Claudia开车和Regina去参加首次由女性担任核电站厂长的董事会议，抱怨着她女儿连把头发梳像样都不肯。

学校里，少女Katharina正在与少女Hannah聊天。这是小Mikkel第一次见到Hannah。此时的校长还是Mr. Hubert（可能是fag？不是我说的，是Katharina说的）

Claudia与门口扫地的Helge交谈，Helge送她一本书当礼物作祝贺。

在报社当记者的Tronte Nielson也要采访Claudia，并且想约她出来重叙旧情。

老警察打赌现在的混混Ulrich Nielson将来绝无可能成为一名警察。并且叫值班的护士Ines来处理Mikkel的伤。

Mikkel无家可归，Ines好心收养他，并改名为Michael。

在对羊检测后，发现所有的羊也有双侧鼓膜破裂症状。

Claudia在老站长（Helge

父亲）进入了核电站的禁区，发现了成吨的桶装核废料。

晚上，各处电力又时断时续，天下落下诸多飞鸟。 在晚上，Ulrich与Hannah幽会，带她看世界末日。

## S1E04

时间切到2002年。Franziska怀疑Elizabeth偷用她的唇膏，但Eliza哑巴，装傻充愣。

Magnus想在课堂上找Franziska，但后者不理他，且手机上看到时间是9:01就出门了。Magnus跟踪Franziska来到树林，她从树叶下面挖出了一个铁盒，从中取了一个包裹后又把空盒埋了回去。

33年前，Charlotte写生的鸟的斑点和现在是一样的。

Jonas根据找到的地图上的标记，来到洞里。之后又在周边搜索，在第一集他等红灯那个路口马路牙子边，找到了一辆把手上挂着红绳的自行车。 

Peter疑似同性恋者，在外做一些苟且之事，Charlotte前去棚屋调查。

Charlotte找到了尸体上相似的红土，同时得知鸟也有双侧鼓膜破裂。但是直接死因是在空中受无线电频段的电磁干扰，失去方向坠地而亡。至于身体上的白色斑点，是切尔诺贝利事件后的突变导致。奇怪的是，在这一带监测不到超量辐射。

棚屋后头有一扇斜嵌在地里的门，通往一个地下室，但她没来得及探索，就被一通电话叫走。原来，Ulrich私自翻越铁栅网被Aleksander抓住了。

Elizabeth今天提前下课，由于等不到家长接又下雨了，她想一个人走回去。路上，她又捡到了Raider零食的包装纸。然后她也失踪了。

Helge说自己得告诉始作俑者Noah，这一切都是循环的，他得住手。

然而戏剧性的一幕是，晚上Elizabeth刚刚自己走到了家。她解释自己晚才走到家的原因是遇到了一个人叫Noah，这个人给了她一块表，并说是Charlotte以前遗失的东西，现在还给她。

“Ariadne的线能指引人们走上正确道路。”

Yasin Tnese被自称Noah派来的人给掳走了。QAQ

## S1E05

Hannah给Ulrich打了数个电话，Matha打电话给Jonas，在他和Bartosz之间举棋不定。Bartosz打电话给Matha被拒接。

根据Elizabeth的描述，Noah如同Peter一样很高，戴着帽子，有一双蓝眼睛。

Charlotte拆穿了Peter在Mikkel失踪当天晚上开车出去的事实，但是Peter认为她疯了。

2052年穿越回来的Jonas若有所思。

Noah通过Eric的手机给Bartosz打了电话，骗他说自己是Eric的药头。Bartosz和Jonas说了，今晚一起去接头。

Hannah直接借送饭的名义跑到Ulrich家里叫他送自己。

1986年的Noah在Mikkel前现身，自称是St. Christopher教堂的神父，向他传教。

青涩的Katharina和Ulrich讨论做爱。Hannah很眼红他俩的关系。

Ulrich讲述了自己从小混混变成警长的理由，就是整治警察局，不让自己弟弟失踪、而警局记录混乱、警长酗酒的无能情况再度发生。但是他觉得自己失败了，让别人失望，于是向Charlotte诉苦。

在2019年，Jonas（2052）和年轻的Jonas见面了，讲了一些玄奥的话。

1986年，Hannah找上了孤独的Mikkel，有些感兴趣。

1986年，Noah添油加醋地举报Ulrich强奸Katharina（实际是两人自愿的），Ulrich错误地怀疑了Regina（因为是警察的孙女）。

Bartosz被Noah放下车了。

Jonas回到家，开箱2052年的自己寄的包裹。有一盏科幻的灯，以及“11月4日10点13分前勿启”的信件。

2052年的Jonas找到1986年的H.G. Tannhaus，想要谈谈时间相关的事。

## S1E06

Regina被当作嫌疑人的噩梦还环绕着她。

Jonas问母亲Hannah是怎么和Michael认识的。说是在医院。

Ulrich翻找1986年9月的档案。Ulrich找到了Tronte谈话，发现Mads失踪当天，Tronte正在和另一个女人Claudia Tiedemann在床上。

Magnus在Eric失踪现场找到了一只鹰/燕子的吊坠（是Franziska的）。旁边还有用过的condom。

Jonas跟着收信器的信号走，到了洞穴里，看见红绳子。他在9点17爬进管道，选择了右边那条，方向不知为何有了改变，穿越到了1986年。

Ulrich终于和Regina解开了误会，发现Hannah Krüger才是举报他的那一个。

Riegina得了癌症，检测机构建议Aleksander送她去Dr. Urman诊疗。

Peter找上Tronte，要等到9点17分。 这和记录完全一致。

Ulrich找到了自己和弟弟的其中一张合照，照片中Mads穿着和死亡小孩一样的黄色太阳连帽衫。

## S1E07

Helge在疗养院里回想起了自己过去在1953年在电击实验房里的故事。此时的他脸上被严重打伤，是本集最后被Ulrich穿越回去打的。

Jonas在1986年遇上了Regina，问到了Ines的地址。

1986年，Martin勒令快退休的Egon暂停调查Ulrich，而专心于Mads失踪案。而在本案中，也有镜像现象。比如，失踪当晚，核电站是Helge值班。他后天会去警局讲述自己的见闻。

Jonas和Charlotte意外发现一条核电站后头去医院的捷径。

Helge自称可以改变过去及未来。画面一转，年轻的他在车上也有Raider的零食。

Jonas找到了Mikkel，本想带他回去，但却被老年的自己阻止。

Jana前几天认出了中年的Helge，与33年前和神父吵架时一样没有变老。

小屋旁边的地下室里有那个诡异房间的痕迹。

Ulrich跟踪Hedge进了洞里，他将穿越到1953年。

中年Helge在未知时间节点给死去的Yisin孩童盖上了大衣，表露出悲伤的神色。

而Noah在清理了地下的血迹后，于地下室的墙壁上用粉笔分别写下了1953年11月5日和1953年11月9日。他背后纹有生命树。

## S1E08

1953年的核电站待建原址上，有两具小孩尸体。一具是Eric，一具是Yisin。

Ulrich在洞穴里，选择了左边的通道。

小Helge战战兢兢地来到了家里，迟到了。给Claudia的硬币放在另一边桌上。

Agnes Nielson这里首次出场，向Ulrich问路。

Gretchen是一只小狗，因为Helge的嫉妒心理，跑进洞穴里失踪了。

Bernd Doppler是Helge的父亲。

Ulrich把Helge打得半死。

Tronte手上有烟烫的伤痕，可能是被遗弃在孤儿院时受到的。

H.G. Tannhaus拒绝为2052年的Jonas修好器械以摧毁虫洞（原理据说是发出与核电站爆炸相同的波）

## S1E09

1953: Agnes的丈夫以前是个牧师，

Bernd的妻子向牧师Noah忏悔，Helge的基因可能不来自于Bernd。

1986年，Claudia检测到洞穴内核废料的当下，她童年养的小狗Gretchen跑了出来。

同一时间，Ulrich出狱，Katharina准备报复无辜的Regina，开头那个中弹的人（Aleksander）冲出来拿枪吓退了Katharina。

中年Helge没有按时去警局接受询问，而是在小木屋做工艺。有个老人（像是老年Helge）躲在树后看了一会儿后走了。

Egon开车来现场，Helge装不在。

Aleksander处理掉枪和护照，真名是Boris Niewald，杀掉的那人护照上是Aleksander Köhler，1965年1月21日生。这个行为被Hannah看到。

Aleksander到Claudia处寻找工作机会。Regina也因此有了改变，开始注意起梳头来。

Noah控制了Helge为他搞实验。

2019年，老年Claudia在Bartosz面前突然出现，请Bartosz给Regina带去以前母女二人的合照。

Hannah以Aleskander以前埋下的黑料要挟，要彻底毁掉Ulrich。

Regina闯入房间，见到中年Jonas写的满房子资料。

Bartosz上了Noah的车，发现预言成真，决定合作。

中年的Jonas找到了藏核废料的车厢。

老年的Claudia从2019穿越回1953年，出现在Tannhaus面前，给他时间机器的图纸。

## S1E10

回顾Mikkel消失当天。Peter开车先到了变性人Bernadette那里，说了小话，然后倒车离开。

Peter到了小屋那里，在地下室里坐下。自扇一巴掌后，开始祈祷。接着，面前展开一道裂缝，从裂缝中掉出了Mads的尸体。他立马通知了Tronte。不久后，Claudia从另一个通往地下室的通道出现，指挥二人把Mads搬运到指定地点。

Ulrich和老年Helge试图在过去做出改变历史的行为，但都失败了。

2019年11月12日，家中苏醒的Jonas接到了他曾经亲手烧毁的同一封信。

重要的情况：由于黑洞的出现，小Helge被放到了1986年，而Jonas被扔到了未来。

## S2E1

时间前推到1921年6月21日，纹身男（中年Bartosz）和年轻人Noah在洞穴里开凿，两人谈话：“开始与结束应该是一体的，Sic mundus creatus est.”并且首次提到了Adam，说6天后天堂开始，地狱结束。

纹身男Bartosz不再相信亚当。Noah把他砍死在地。

2020年6月27日，即是上个周期的开始

下一幕，裸体的Jonas和Martha在做爱，穿越到2052年的Jonas从梦中惊醒。他在破败的小镇中穿行，到了地下室里逐步了解2020年6月的事。

2020年6月21日，灾难发生的6天前，也是暑假的第一天，小镇里失踪了6个人已逾半年。画面转到Jonas一家人的合照，这才发现原来的照片其实是有四个人的，只是被裁掉了Ines，变成了一家三口。

Clausen作为专案组的组长，来到Winden调查大规模失踪案件。

Franziska和Magnus互相安慰，之后她说去接Elizabeth后走了，Magnus有些担心。跟踪后发现她去树林里往铁盒里放了什么。结果变性人Bernadette取走了。

长得像Ulrich的年轻人Noah去到教堂，给他传教的正是中年的Noah！

未来以军事手段守护通道的Elizabeth想拉拢Jonas。

时间回到2019年，Elizabeth问父亲为何母亲还留着曾祖父的东西。有一张合照是小时候的Charlotte和老年Tannhaus。

在未知的时间，老年Adam一定要中年Noah制造世界末日。

Elizabeth在她祖父的一张老合照中发现了Noah。

混进警局卧底的眼罩哥Wöller居然和Bernadette/Benni是亲人。

中年Jonas带Hannah回过去。

1986年，老年的Claudia去见中年Claudia，托付给她阻止Adam的使命。

Jonas从坦克里偷油，但想去开上帝之门时被抓。后来成功了。

## S2E2

Agnes和Noah是姐弟。

## S2E4

Jonas到了1921年，被纹身男和长得像Ulrich的年轻人引走去Erna暂住，门口见到了幼年的Agnes。

2020年6月24日，这次轮到Martha梦见Jonas和Martha在湖中小屋做爱，并惊醒。

年轻的Noah找上了Jonas。Jonas试图在1921年穿越洞穴，但此时还没能起到两头连通的作用。

原来，Noah隶属的组织叫Sic mundus。

1987年6月26日老督察Egon去世。

Adam自称是老年的Jonas。

## S2E5

Noah是Charlotte的父亲，母亲和Charlotte同时从Noah身边被带走。

在1921年，Adam给Jonas看了希格斯场的原型机（和未来那个一样），可以随意去日期，并结束这一切。问题在于，怎样确定一切的开始在哪里

Jonas前往2019年6月20日，即一切发生的前一天。

Michael有了既视感，Mikkel得了风疹。

与老年Adam对话的是中年Magus和中年Franziska(存疑)

## S2E6

Claudia试图阻止Egon在1986年死去。

Hannah偷拿了中年Jonas的时光机，去往1953年找Ulrich.

Aleskander身份暴露。

## S2E8

在世界末日前夕，青年Noah找到Jonas，给他来自Martha的信，并且要求他救下：Bartosz、Magnus、Franziska、自己和Agnes。说这样才可能救Martha。且看了信后，他就会变成Adam。

Adam出现于正在热吻的Jonas和Martha面前，说要上帝物质作触发引子，说着掏出枪干掉Martha。

2020年的核电站和2053年的地方联通，Charlotte&Elizabeth母女相认。

Karthalina穿越时间到了某一年。

捧着Martha尸体的Jonas遇到了来自另一个世界的Martha

## S3E1

Martha带他穿越世界洞穴里后，说一切是从二人相识开始的，她会终结两个世界的纠缠，说着自己传送走了，留下Jonas一个人。

镜像世界，2019年11月4日。Martha从梦中惊醒。床位和S1E1的Jonas正好是反的。

这个世界，Katharina戴眼镜，是教师，并且和丈夫分居，Mikkel比我们熟知的更成熟， 在床上和Magus交合的是Franziska。然后她从外墙爬出去了。

Ulrich和Hannah在这个世界是一对，可能是和Katharina离婚后去的，Hannah有身孕，怀疑Ulrich偷情。Ulrich在警察局里任长官，与Charlotte偷情。

镜像世界中，穿着醒目黄色雨衣的是Martha。与S1E1相仿，只不过是在浓雾中骑车。她望向电线杆上的寻人启事，上面找的是Erik。

原世界的Jonas从洞穴中走出。

Martha在镜像世界中，和Kilian是情侣。

Aleksander还管理核电站，但是好像患了病。Regina已经去世。

Magus和Franziska在地下室幽会。（Franziska此时是聋哑人，Elizabeth会说话）

Peter是教堂的牧师。说这里只有Daniel Kahnwald，死于1964年。Peter提到以前似乎见过，但Jonas没有告诉他自己的名字。

在原世界的1987年9月21日，嘴唇上有伤的少年/中年/老年的（Kilian？）找到了在轮椅上的Bernd，说对方还留着核电站的万能钥匙。然后勒死了Bernd.

在小孩小队（Magnus, Franziska, Killian, Martha）在洞穴边找Erik时，听到了怪声。这次换Martha跑丢，见到了未来的另一个Martha（？），四个人后来去地下室避难，见到了被传送过来的Mads。

Jonas见到了Eva，是未来的Martha。

原世界1888年9月21日，中年Jonas正在操作Tannhaus的机器，Martha来帮他寻找两个世界共同的起源。

## S3E4

原来Jonas、Martha共有的那条链坠最初是Egon给Hannah的。Hannah留给了小Helene，并且假称自己是Katharina时，Helene记下了这个很美的名字，日后给自己女儿叫这个名儿。

## S3E5

至于为什么链坠最开始是在湖边捡到的，这是因为Katharina回到过去，与母亲在湖边打斗时把她脖子上的链坠扯下来了。

